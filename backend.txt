# ESPECIFICACIÓN TÉCNICA BACKEND - REPRODUCTOR MUSICAL SPOTIFY/YOUTUBE

## ARQUITECTURA GENERAL

### Visión de Alto Nivel

Arquitectura backend escalable, segura y de alto rendimiento para soportar una aplicación de streaming musical que integra datos de Spotify para búsqueda/metadata y YouTube para reproducción.

```
                  ┌───────────────┐
                  │  Cliente Web  │
                  │ (Next.js App) │
                  └───────┬───────┘
                          │
                          ▼
┌──────────────────────────────────────────────┐
│                  API Gateway                  │
└──────────┬───────────────┬──────────┬────────┘
           │               │          │
           ▼               ▼          ▼
┌──────────────┐  ┌─────────────┐  ┌─────────────┐
│ Servicio de  │  │ Servicio de │  │ Servicio de │
│Autenticación │  │  Contenido  │  │  Usuario    │
└──────┬───────┘  └────┬────────┘  └─────┬───────┘
       │               │                 │
       │               │                 │
       ▼               ▼                 ▼
┌──────────────┐  ┌─────────────┐  ┌─────────────┐
│  Base de     │  │ Adaptadores │  │  Base de    │
│  Datos de    │  │   de API    │  │  Datos de   │
│  Auth        │  │ (Spotify/YT)│  │  Usuario    │
└──────────────┘  └─────────────┘  └─────────────┘
```

### Enfoque Arquitectónico

- **Patrón**: Arquitectura de microservicios con API Gateway
- **Comunicación**: REST para endpoints públicos, gRPC para comunicación interna entre servicios
- **Deployment**: Contenedores Docker orquestados con Kubernetes
- **Escalabilidad**: Horizontal por servicio según necesidades
- **Resiliencia**: Circuit breakers, retries, y backoff exponencial

## STACK TECNOLÓGICO

### Lenguajes y Frameworks

- **Principal**: Node.js con TypeScript
- **Framework API**: NestJS (estructura modular, inyección de dependencias)
- **Alternativa**: Go para servicios críticos de rendimiento

### Bases de Datos

- **Principal**: MongoDB (datos de usuario, playlists, caché)
  - **ORM**: Mongoose con esquemas estrictos
  - **Índices**: Optimizados para patrones de búsqueda frecuentes
  - **Sharding**: Preparación para escalar horizontalmente

- **Caché**: Redis
  - **Uso**: Tokens, resultados de búsqueda, mapeo Spotify-YouTube
  - **Estrategia**: Time-based expiration con invalidación inteligente
  - **Estructuras**: Optimizadas por caso de uso (strings, hashes, sorted sets)

### Sistemas Auxiliares

- **Message Queue**: RabbitMQ
  - **Casos de uso**: Tareas asíncronas, eventos del sistema, procesos batch
  - **Patrones**: Pub/Sub para eventos, Workers para tareas pesadas

- **Búsqueda**: Elasticsearch (opcional)
  - **Uso**: Búsqueda avanzada de playlists y contenido
  - **Índices**: Optimizados para búsqueda textual y facetada

- **Logging/Monitoring**: 
  - ELK Stack (Elasticsearch, Logstash, Kibana)
  - Prometheus + Grafana para métricas operacionales

## SERVICIOS CORE

### 1. Servicio de Autenticación y Usuarios

#### Funcionalidad
- Registro y autenticación de usuarios
- Gestión de sesiones y tokens
- Integración OAuth con Spotify y Google
- Perfiles de usuario y preferencias
- Control de acceso basado en roles/permisos

#### Consideraciones Técnicas
- **Tokens**: JWT con rotación de refresh tokens
- **Seguridad**: 
  - Almacenamiento de contraseñas con bcrypt (costo 12+)
  - Protección contra ataques de fuerza bruta
  - Rate limiting por IP y usuario
- **Sesiones**: 
  - Invalidación remota para casos de seguridad
  - Device tracking y gestión de sesiones múltiples

#### Schemas de Datos
```typescript
// Usuario
interface User {
  id: string;
  email: string;
  passwordHash: string;
  name: string;
  avatarUrl?: string;
  createdAt: Date;
  updatedAt: Date;
  lastLogin: Date;
  preferences: UserPreferences;
  roles: Role[];
  isActive: boolean;
  spotify: {
    connected: boolean;
    refreshToken?: string;
    tokenExpiresAt?: Date;
    userId?: string;
  };
  youtube: {
    connected: boolean;
    refreshToken?: string;
    tokenExpiresAt?: Date;
    channelId?: string;
  };
}

// Sesión
interface Session {
  id: string;
  userId: string;
  refreshToken: string;
  expiresAt: Date;
  deviceInfo: {
    ip: string;
    userAgent: string;
    deviceId: string;
  };
  isValid: boolean;
  lastActive: Date;
}
```

### 2. Servicio de Gestión de Contenido

#### Funcionalidad
- Buscar contenido en Spotify
- Mapear contenido de Spotify a YouTube
- Gestionar metadatos y enriquecimiento
- Mantener caché de resultados populares
- Generar recomendaciones

#### Consideraciones Técnicas
- **Caché**: 
  - Multi-nivel (memoria, Redis, persistente)
  - Políticas de expiración personalizadas por tipo de contenido
  - Invalidación selectiva
- **Rate Limiting**: 
  - Gestión de cuotas API de Spotify y YouTube
  - Throttling adaptativo para evitar bloqueos
  - Cola de prioridad para solicitudes críticas
- **Fallbacks**:
  - Estrategias alternativas cuando un servicio falla
  - Degradación graciosa de funcionalidad

#### Sistema de Mapeo Spotify-YouTube
- **Algoritmo**: 
  - Búsqueda multi-fase con sistema de puntuación
  - Factores: título, artista, duración, popularidad
  - Machine learning para mejora continua de coincidencias
- **Persistencia**:
  - Guardar mapeos validados para uso futuro
  - Feedback de usuario para correcciones

#### Schemas de Datos
```typescript
// Mapeo entre servicios
interface ContentMapping {
  id: string;
  spotifyId: string;
  spotifyType: 'track' | 'album' | 'artist' | 'playlist';
  spotifyData: {
    title: string;
    artist: string;
    duration: number;
    albumName?: string;
    releaseDate?: Date;
  };
  youtubeId: string;
  youtubeData: {
    title: string;
    channelId: string;
    duration: number;
    viewCount?: number;
  };
  confidenceScore: number; // 0-100
  verified: boolean;
  createdAt: Date;
  updatedAt: Date;
  usageCount: number;
  userFeedback: {
    positive: number;
    negative: number;
  };
}

// Caché de búsqueda
interface SearchCache {
  id: string;
  query: string;
  serviceType: 'spotify' | 'youtube';
  resultHash: string; // Hash de los resultados
  results: any; // Resultados de búsqueda serializados
  createdAt: Date;
  expiresAt: Date;
  hitCount: number;
}
```

### 3. Servicio de Biblioteca y Playlists

#### Funcionalidad
- Gestión de bibliotecas de usuario
- Creación y edición de playlists
- Historial de reproducción
- Favoritos y colecciones
- Sincronización con servicios externos

#### Consideraciones Técnicas
- **Concurrencia**: 
  - Bloqueo optimista para ediciones de playlist
  - Resolución de conflictos
- **Consistencia**:
  - Transacciones para operaciones multi-documento
  - Reconciliación para cambios offline
- **Performance**:
  - Paginación y carga progresiva
  - Vistas materializadas para accesos frecuentes

#### Schemas de Datos
```typescript
// Playlist
interface Playlist {
  id: string;
  name: string;
  description?: string;
  coverImageUrl?: string;
  ownerId: string;
  isPublic: boolean;
  collaborators: {
    userId: string;
    permissions: 'view' | 'edit' | 'manage';
    addedAt: Date;
  }[];
  tracks: {
    id: string;
    spotifyId?: string;
    youtubeId?: string;
    title: string;
    artist: string;
    albumName?: string;
    duration: number;
    addedAt: Date;
    addedBy: string;
  }[];
  stats: {
    totalTracks: number;
    totalDuration: number;
    plays: number;
    followers: number;
    lastModified: Date;
  };
  tags: string[];
  createdAt: Date;
  updatedAt: Date;
}

// Historial de reproducción
interface PlayHistory {
  id: string;
  userId: string;
  track: {
    id: string;
    spotifyId?: string;
    youtubeId?: string;
    title: string;
    artist: string;
    albumName?: string;
  };
  playedAt: Date;
  playDuration: number; // duración real reproducida en ms
  completionRate: number; // 0-1, qué porcentaje se reprodujo
  source: 'playlist' | 'search' | 'recommendation' | 'radio';
  sourceId?: string; // ID de playlist, etc. si aplica
  deviceInfo: {
    type: 'desktop' | 'mobile' | 'tablet' | 'web';
    os?: string;
    browser?: string;
  };
}
```

### 4. Servicio de Streaming y Proxy

#### Funcionalidad
- Proxy para peticiones a YouTube
- Optimización de streaming
- Gestión de calidad de audio
- Métricas de consumo de datos

#### Consideraciones Técnicas
- **Seguridad**:
  - Ocultación de claves API
  - Prevención de abuso con rate limiting por usuario
  - Validación de tokens y permisos
- **Performance**:
  - Buffering inteligente
  - Adaptación de calidad según ancho de banda
- **Resiliencia**:
  - Múltiples instancias detrás de balanceador
  - Recuperación automática de fallos

#### Endpoints Principales
```
GET /api/stream/prepare/:platformId
- Prepara una sesión de streaming, devuelve tokens temporales

GET /api/stream/youtube/:videoId
- Proxy para streaming desde YouTube con autenticación y análisis

POST /api/stream/feedback
- Recopila feedback sobre calidad de streaming y mapeo
```

## GESTIÓN DE DATOS Y ALMACENAMIENTO

### Estrategia de Base de Datos

- **Particionamiento**:
  - Sharding por usuario para datos personales
  - Colecciones separadas para contenido de alta frecuencia
  - Índices específicos por patrones de acceso
  
- **Respaldo**:
  - Backups incrementales diarios
  - Backups completos semanales
  - Retención de 30 días con archivado a cold storage
  - Pruebas de restauración programadas

- **Evolución de Esquemas**:
  - Migrations automatizadas con rollback
  - Versionado de esquemas
  - Compatibilidad hacia atrás

### Estrategia de Caché

#### Niveles de Caché
1. **L1**: Memoria en aplicación (Node.js)
   - Datos de referencia (listas de valores, configuraciones)
   - TTL corto (1-5 minutos)
   - Volumen pequeño (<100MB por instancia)

2. **L2**: Redis distribuido
   - Sesiones de usuario
   - Resultados de búsqueda
   - Mapeos Spotify-YouTube
   - Data temporal compartida entre servicios
   - TTL variable (10 minutos - 24 horas)

3. **L3**: MongoDB con índices
   - Consultas frecuentes con resultados materializados
   - Actualización por eventos o periódica
   - Queries pre-calculadas

#### Políticas de Caché
- **Time-Based**: Expiración después de tiempo definido
- **Usage-Based**: LRU para contenido menos usado
- **Update-Based**: Invalidación por cambios en datos fuente
- **Stale-While-Revalidate**: Devolver datos antiguos mientras se actualiza en background

#### Métricas de Caché
- Hit ratio por nivel y tipo de contenido
- Latencia de recuperación
- Tamaño de caché
- Frecuencia de invalidaciones

## SEGURIDAD Y CONFORMIDAD

### Protección de Datos

- **En Tránsito**: 
  - TLS 1.3 obligatorio para todas las conexiones
  - Certificados con rotación automática
  - HTTP Strict Transport Security (HSTS)

- **En Reposo**:
  - Encriptación AES-256 para datos sensibles
  - Tokenización de información personal
  - Separación lógica de datos PII

- **Anonimización**:
  - Datos de análisis sin información identificable
  - Proceso de anonimización para reportes

### Autenticación y Autorización

- **Autenticación**:
  - OAuth 2.0 + PKCE para flujos web/móvil
  - MFA opcional para usuarios
  - Detección de dispositivos desconocidos
  
- **Autorización**:
  - RBAC (Role-Based Access Control)
  - Permisos granulares por recurso
  - Contexto adicional (tiempo, ubicación, dispositivo)

- **API Security**:
  - Rate limiting adaptativo
  - Validación estricta de esquemas
  - Tokenización de todas las solicitudes

### Auditoría y Compliance

- **Logging**:
  - Logs centralizados con retención configurable
  - Registro detallado de acciones administrativas
  - Alertas por patrones sospechosos

- **Compliance**:
  - GDPR: Controles para datos personales europeos
  - CCPA: Opciones para residentes de California
  - Términos de servicio API de Spotify y YouTube

## INTEGRACIÓN CON APIs EXTERNAS

### Spotify API

- **Endpoints principales**:
  - Search API: Para búsquedas generales
  - Browse API: Para contenido destacado
  - Tracks/Albums/Artists APIs: Para metadata
  - Personalization API: Para recomendaciones
  
- **Consideraciones**:
  - Límites: 429 requests/usuario/minuto
  - Rate limiting con backoff exponencial
  - Caché agresivo para resultados frecuentes
  
- **Estrategia de Tokens**:
  - Refresh token flow con servidor seguro
  - Rotación de API keys por entorno
  - Prevención de expiración con renovación proactiva

### YouTube API

- **Endpoints principales**:
  - Search API: Para encontrar videos musicales
  - Videos API: Para metadata
  - IFrame Player API: Para embeber reproductor
  
- **Consideraciones**:
  - Cuota diaria: 10,000 unidades/día
  - Priorización de solicitudes críticas
  - Optimización de parámetros de búsqueda
  
- **Optimización de cuota**:
  - Búsquedas por lotes
  - Reducción de campos solicitados
  - Caché agresivo para resultados frecuentes

### Estrategia de Fallback

- **Detección de fallos**:
  - Monitoreo proactivo del estado de APIs
  - Circuit breaker para prevenir cascadas
  
- **Rutas alternativas**:
  - Fuentes secundarias para metadata
  - Caché extendido durante interrupciones
  - Degradación graciosa de funcionalidad

- **Comunicación al usuario**:
  - Mensajes claros sobre limitaciones temporales
  - Opciones alternativas cuando disponibles
  - Expectativas realistas sobre recuperación

## INFRAESTRUCTURA Y DEVOPS

### Entornos de Despliegue

- **Producción**:
  - Multi-AZ en proveedor cloud principal
  - Replicación geográfica para baja latencia
  - Escalado automático basado en carga
  
- **Staging**:
  - Réplica a escala de producción
  - Datos anonimizados pero representativos
  - Pruebas de rendimiento y carga
  
- **Desarrollo**:
  - Instancias ligeras para cada equipo
  - Datos de prueba generados
  - Servicios mockeados cuando necesario

### CI/CD

- **Pipeline**:
  - Construcción en cada push
  - Tests unitarios, integración, y e2e
  - Análisis estático de código
  - Verificación de dependencias
  
- **Despliegue**:
  - Estrategia Blue/Green para zero downtime
  - Canary releases para cambios críticos
  - Rollback automático ante métricas anómalas
  
- **Infraestructura como Código**:
  - Terraform para provisión de recursos
  - Helm charts para despliegue Kubernetes
  - Secrets gestionados con Vault

### Monitoreo y Observabilidad

- **Métricas operacionales**:
  - CPU, Memoria, Disco, Red
  - Latencia de endpoints
  - Errores y excepciones
  - Cuotas y límites de APIs externas
  
- **Métricas de negocio**:
  - Usuarios activos
  - Canciones reproducidas
  - Retención y engagement
  - Calidad de coincidencias Spotify-YouTube
  
- **Alerting**:
  - Definición de SLOs/SLAs
  - Alertas preventivas basadas en tendencias
  - Escalado a personal de guardia
  - Documentación de respuesta a incidentes

## RENDIMIENTO Y ESCALABILIDAD

### Optimizaciones de Rendimiento

- **API Gateway**:
  - Caché de nivel de edge
  - Compresión GZIP/Brotli
  - Optimización de rutas para latencia

- **Servicios**:
  - Connection pooling para bases de datos
  - Batch processing para operaciones masivas
  - Ejecución asíncrona para tareas no críticas
  
- **Database**:
  - Índices compuestos para consultas frecuentes
  - Consultas proyectadas (sólo campos necesarios)
  - Read replicas para balanceo de carga

### Estrategias de Escalado

- **Horizontal**:
  - Auto-scaling basado en CPU y memoria
  - Pods adicionales durante horas pico
  - Escala por microservicio según necesidad
  
- **Vertical**:
  - Incremento de recursos para nodos críticos
  - Optimización de memoria/CPU por workload
  - Instancias especializadas para casos extremos
  
- **Datos**:
  - Sharding por usuario para MongoDB
  - Clústeres Redis para distribución de carga
  - Particionamiento de logs por fecha/servicio

### Pruebas de Carga

- **Escenarios**:
  - Uso normal: 1000 req/s sostenido
  - Pico: 5000 req/s por 30 minutos
  - Estrés: 10000 req/s hasta degradación
  
- **Métricas clave**:
  - P95/P99 latencia por endpoint
  - Error rate bajo carga
  - Tiempo de recuperación post-pico
  - Límites de escalado por componente

## ROADMAP DE IMPLEMENTACIÓN

### Fase 1: Fundamentos (4 semanas)
- Estructura base de microservicios
- Autenticación y gestión de usuarios
- Integración básica con Spotify API
- Almacenamiento de datos core

### Fase 2: Funcionalidad Core (6 semanas)
- Integración completa Spotify + YouTube
- Mapeo bidireccional entre plataformas
- Sistema de gestión de playlists
- Historial y favoritos

### Fase 3: Optimización y Escalabilidad (4 semanas)
- Implementación de caché multi-nivel
- Sistemas de fallback robustos
- Monitoreo y alertas
- Load testing y optimizaciones

### Fase 4: Características Avanzadas (4 semanas)
- Recomendaciones personalizadas
- Funcionalidades sociales
- Análisis musical avanzado
- Integración de letras y metadata enriquecida

## CONSIDERACIONES DE MANTENIMIENTO

### Actualización de Dependencias
- Revisión semanal de vulnerabilidades
- Actualización mensual de dependencias no críticas
- Pruebas de regresión automatizadas para upgrades

### Gestión de Crecimiento
- Proyecciones de crecimiento de datos por 12 meses
- Plan de sharding proactivo
- Estrategia de archivado para datos históricos

### Optimización Continua
- Análisis semanal de endpoints lentos
- Revisión de patrones de consulta más costosos
- Métricas de rendimiento comparadas con línea base 