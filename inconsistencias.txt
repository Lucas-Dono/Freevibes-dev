# Inconsistencias en el Proyecto FreeVibes

## Inconsistencias en variables de entorno

1. **Múltiples archivos .env**:
   - `.env` en la raíz
   - `.env.example` en la raíz
   - `node-server/.env`
   - `node-server/.env.example`
   - `python-api/.env`
   - `python-api/.env.example`

2. **Diferentes nombres para las mismas variables**:
   - En `.env` y `.env.example`: `NEXT_PUBLIC_NODE_API_URL`
   - En `node-server/.env` y `node-server/.env.example`: `SERVER_PORT`
   - Para la URL del frontend: `NEXT_PUBLIC_APP_URL` vs `FRONTEND_URL`
   - Para la URL de la API Python: `NEXT_PUBLIC_PYTHON_API_URL` vs `YOUTUBE_API_URL`
   - En `python-api/.env`: `PORT` vs `SERVER_PORT` en Node

3. **Variables obsoletas pero aún referenciadas**:
   - En `.env.example` se marcan como obsoletas `BACKEND_URL` y `NEXTAUTH_URL`, pero están aún en uso en `src/app/api/auth/login/route.ts` y `src/app/api/auth/register/route.ts` (hay comentarios que indican que se reemplazó `BACKEND_URL` por `NODE_API_URL`)

4. **Diferentes formas de acceder a las variables de entorno**:
   - En `src/lib/server-utils.ts`: Acceso directo a `process.env.NEXT_PUBLIC_NODE_SERVER_URL`
   - En `src/components/ServerStatus.tsx`: Acceso a través de `env.NODE_SERVER_URL` y fallback a `process.env.NEXT_PUBLIC_NODE_SERVER_URL`
   - En `src/lib/auth.ts`: Acceso directo a `process.env.SPOTIFY_CLIENT_ID`
   - En `src/env.mjs`: Centralización parcial en objeto `env`
   - En `python-api/app.py`: Acceso a través de `os.environ.get('PORT', 5000)`

5. **Credenciales hardcodeadas en archivos .env**:
   - En `.env` hay credenciales reales para varios servicios (Spotify, MongoDB, Last.fm, etc.)
   - En `python-api/.env` hay una clave de API de YouTube
   - En `node-server/.env` hay credenciales de Spotify

6. **Inconsistencias en valores de variables**:
   - En `python-api/.env`: `PORT=5100` pero en el código se usa fallback a 5000
   - En diferentes configuraciones los mismos servicios tienen timeouts distintos

## Inconsistencias en definición de URLs base

1. **Múltiples implementaciones de `getApiBaseUrl()`**:
   - En `src/services/utils/api-config.ts`: Implementación centralizada que devuelve `/api`
   - En `src/services/spotify.ts`: Implementación duplicada similar
   - En `src/config/api-config.ts`: Otra implementación que devuelve `${window.location.origin}/api`
   - En `src/lib/api-config.ts`: Implementación que devuelve `window.location.origin` (sin `/api`)
   - En `src/services/recommendations/sources/spotify.ts`: Implementación duplicada
   - Otras implementaciones encontradas con grep en múltiples archivos

2. **URLs hardcodeadas en servicios**:
   - En `src/services/youtube/youtube-music-api.ts`: URL base hardcodeada como una constante
   - En `node-server/server.js`: URLs hardcodeadas para servicios
   - En `src/lib/spotify.ts`: URL hardcodeada de la API de Spotify `https://api.spotify.com/v1${endpoint}`
   - En `src/app/api/spotify/route.ts`: URL hardcodeada para construir una petición al servidor Node
   - En `vercel.json`: URL hardcodeada de Render `https://musicverse-node-api.onrender.com/api/:path*`
   - En `python-api/app.py`: URL hardcodeada `host='0.0.0.0'`

3. **Inconsistencias en construcción de URLs**:
   - Algunos servicios añaden `/api` al final de la URL base, otros no
   - Algunos usan `${apiBaseUrl}/spotify` y otros `${apiBaseUrl}/api/spotify`
   - Algunos añaden `/api` en la función `getApiBaseUrl()`, otros lo agregan al usar la función
   - En `node-server/server.js` y `python-api/youtube_music_api.py` hay diferentes formatos de construcción de URL

## Inconsistencias en función getApiBaseUrl

1. **Implementaciones con lógica similar pero no idéntica**:
   - En algunos casos se usa `window.location.origin`, en otros `window.location.protocol + hostname + port`
   - Algunos verifican primero `process.env.NEXT_PUBLIC_APP_URL`, otros no
   - Algunos devuelven `/api` como valor por defecto, otros `http://localhost:3000/api`

2. **Fallbacks inconsistentes**:
   - En `src/services/utils/api-config.ts`: Fallback a `/api`
   - En `src/config/api-config.ts`: Fallback a `http://localhost:3000/api`
   - En `src/lib/api-config.ts`: Fallback a `http://localhost:3000` (sin `/api`)
   - En `node-server/server.js`: Fallbacks con puertos inconsistentes
   - En `python-api/app.py`: Fallback a puerto 5000

3. **Uso inconsistente en componentes**:
   - Algunos componentes importan `getApiBaseUrl` de `@/lib/api-config`, otros de `@/services/utils/api-config`
   - Algunos componentes usan `API_CONFIG.getApiBaseUrl()` en lugar de importar la función directamente

## Inconsistencias en URLs hardcodeadas

1. **URLs hardcodeadas en lugar de usar constantes**:
   - En `src/lib/spotify.ts` varias URLs hardcodeadas: `https://api.spotify.com/v1${endpoint}`
   - En `node-server/server.js` múltiples URLs hardcodeadas
   - En `src/app/api/spotify/route.ts` URL hardcodeada para construir una petición al servidor Node
   - En `vercel.json` URL hardcodeada para Render
   - En `next.config.js` múltiples dominios hardcodeados para configuración de imágenes

2. **Mezcla de URLs relativas y absolutas**:
   - Algunos servicios usan `/api/endpoint`
   - Otros usan `http://localhost:3001/api/endpoint`
   - Esto puede causar problemas en entornos de producción

## Inconsistencias en configuración de CORS

1. **Diferentes configuraciones de CORS en distintos archivos**:
   - En `node-server/server.js` se define un objeto de configuración CORS específico
   - En `.env.example` y `node-server/.env.example` se usan diferentes variables para configurar CORS
   - En `vercel.json` se definen reglas CORS distintas a las del servidor Node
   - En `python-api/app.py` la configuración CORS está comentada porque ya está en `youtube_music_api.py`
   - En `python-api/youtube_music_api.py` CORS se configura directamente con el origen de la variable de entorno

2. **Gestión inconsistente de CORS en servicios**:
   - Algunos endpoints usan CORS genérico, otros CORS específico
   - En `node-server/server.js`: `app.use('/status', cors(openCorsOptions))` está comentado pero otros endpoints similares están activos
   - En `python-api/app.py` hay configuración CORS comentada que podría causar confusión

## Inconsistencias en nombres de variables

1. **Distintos formatos para nombrar servicios de API**:
   - Para YouTube Music se usan: `YOUTUBE_API_URL`, `PYTHON_API_URL`, `YTMUSIC_API_URL`
   - Para Spotify: `SPOTIFY_API_BASE`, `NEXT_PUBLIC_SPOTIFY_CLIENT_ID`
   - Mezcla de prefijos `NEXT_PUBLIC_` y sin prefijo para variables que se usan en el cliente

2. **Inconsistencia entre código y documentación**:
   - En `docs/es/TECHNICAL.md` y `docs/en/TECHNICAL.md` se usan valores diferentes para las mismas variables
   - Los valores en `docs/es/TECHNICAL.md` no coinciden con los del código

## Inconsistencias en manejo de errores

1. **Diferentes estrategias de reintentos**:
   - `src/services/youtube/youtube-music-api.ts` implementa una función `withRetry`
   - `src/services/spotify.ts` usa `throttleApiCalls` con parámetros específicos
   - `src/lib/spotify.ts` implementa su propio sistema de reintentos para errores 429
   - `python-api/youtube_music_api.py` tiene un decorador `@cached` con lógica propia de reintentos
   - Diferentes valores de timeout y reintentos máximos

2. **Manejo inconsistente de respuestas de error**:
   - En algunos casos se devuelve un array vacío `[]`
   - En otros se devuelve un objeto `{ error: string }`
   - En algunos casos se reintenta la petición, en otros se usa un fallback
   - En `python-api/youtube_music_api.py` los errores se registran con `logger.error`
   - En `node-server/server.js` los errores se imprimen con `console.error`

## Inconsistencias en cacheo

1. **Diferentes implementaciones de cache**:
   - En `src/lib/spotify.ts` se implementa un sistema de cache basado en `Map`
   - En `node-server/server.js` se usa `NodeCache`
   - En `python-api/youtube_music_api.py` se implementa un sistema de cache basado en archivos y un decorador `@cached`
   - En algunos servicios se implementa manualmente `localStorage`

2. **Diferentes tiempos de expiración**:
   - `src/lib/spotify.ts`: 5 minutos para cache de API
   - `python-api/youtube_music_api.py`: `CACHE_DURATION = 3600` (1 hora)
   - `.env`: `CACHE_TTL=600` (10 minutos)
   - En la configuración: Valores diferentes para diferentes tipos de datos

## Inconsistencias en modo demo

1. **Diferente manejo del modo demo**:
   - En `src/services/spotify.ts` se usa `IS_DEMO_MODE` (variable global)
   - En `src/config/api-config.ts` se define `isDemoMode()`
   - En `node-server/server.js` se usa `isDemoMode(req)`
   - En `src/app/api/spotify/route.ts` se verifica con cookies y headers
   - En `src/lib/auth.ts` se define `isInDemoMode()` que usa `cookies()` de next/headers
   - En `src/components/ServerStatus.tsx` se llama a `isDemoAvailable()` de `src/lib/server-utils.ts`
   - En `node-server/demo-handler.js` hay lógica específica para datos demo con un enfoque de implementación totalmente diferente

## Inconsistencias en tipado

1. **Definiciones de tipos duplicadas**:
   - En `src/contexts/PlayerContext.tsx` se redefinen los tipos `Track` y `LyricLine`
   - En `src/types/types.ts` y `src/types/music.ts` hay interfaces similares para los mismos conceptos (Track, Artist, Playlist)
   - Se usa `export type Track = AppTrack;` para re-exportar tipos
   - Se define `ExtendedTrack extends Track` con campos adicionales

2. **Tipado inconsistente en las respuestas API**:
   - Algunos servicios devuelven tipos específicos, otros `any`
   - Uso inconsistente de interfaces vs types
   - `python-api/youtube_music_api.py` no tiene tipado (Python sin type hints)
   - `node-server/server.js` no tiene tipado (JavaScript sin TypeScript)

## Inconsistencias en la arquitectura de archivos

1. **Estructura de directorios inconsistente**:
   - Múltiples ubicaciones para archivos de configuración: `src/lib`, `src/config`, `src/services/utils`
   - Duplicación de funcionalidad en diferentes capas
   - `python-api` tiene copias de seguridad y archivos duplicados: `youtube_music_api.py.backup`, `youtube_music_api_fixed.py`, etc.

2. **Mezcla de paradigmas de autenticación**:
   - Se usa NextAuth en `src/lib/auth.ts`
   - Se implementa autenticación manual en `src/app/api/auth/login/route.ts`

3. **Diferentes enfoques de logging**:
   - `python-api/youtube_music_api.py` usa un logger configurado con `logging`
   - `node-server/server.js` usa `console.log` directamente
   - `src` mezcla ambos enfoques en diferentes archivos

## Inconsistencias en puertos de desarrollo

1. **Diferentes puertos utilizados**:
   - Frontend: 3100 en `.env`, pero 3000 en URLs de callback
   - Node Server: 3101 en `.env`, 3001 en algunos comentarios
   - Python API: 5100 en `.env`, 5000 como fallback en código

## Inconsistencias en API de YouTube y servicios relacionados

1. **Diferentes implementaciones para acceder a la API de YouTube Music**:
   - En `src/services/youtube/youtube-music-api.ts` se define `YTMUSIC_API_URL = \`${API_CONFIG.getNodeApiUrl()}/api/youtube\`` pero en otros lugares se usa `PYTHON_API_URL` o URLs hardcodeadas
   - La constante `baseURL = YTMUSIC_API_URL` se usa para crear una instancia de axios, pero luego algunas funciones construyen URLs completas ignorando esta configuración
   - En `node-server/server.js` se implementa un proxy que redirecciona a la API de YouTube Music en Python, pero también hay lógica de negocio adicional

2. **Inconsistencias en manejo de errores para YouTube**:
   - En `src/services/youtube/youtube-music-api.ts` existe una constante `SHOW_YT_MUSIC_ERRORS = false` que silencia errores, mientras que otras APIs muestran todos los errores
   - `MAX_RETRY_ATTEMPTS = 2` para YouTube Music pero otros servicios usan valores diferentes
   - La función `withRetry` tiene lógica específica para YouTube Music que no se comparte con otros servicios

3. **URLs y endpoints inconsistentes para YouTube**:
   - La API de YouTube Music se accede a través de múltiples rutas:
     - `/api/youtube` (frontend a Node)
     - `/youtube` (Node a Python)
     - Directamente a `http://localhost:5000` en algunos casos hardcodeados
   - Los métodos REST no son consistentes: algunos usan `GET` con parámetros, otros `POST` con body

4. **Múltiples implementaciones de cacheo para YouTube**:
   - En Python: Sistema de cacheo basado en archivos con duración de 1 hora
   - En Node: Una implementación con `NodeCache` con TTL configurable
   - En frontend: Caché en memoria + localStorage con duración no especificada claramente

5. **Inconsistencias en tipos de datos YouTube**:
   - `YTMusicResult`, `YTMusicLyrics`, `LyricLine` definidos en múltiples lugares con propiedades diferentes
   - El servicio Python devuelve respuestas con formato inconsistente dependiendo del endpoint
   - La transformación entre los modelos de datos de YouTube y los modelos internos varía entre diferentes servicios

## Inconsistencias en el manejo de historial y reproducción

1. **Tipos inconsistentes para playedAt**:
   - En `IRecentTrack` se define como `Date`
   - En `EnrichedTrack` se define como `number | Date`
   - En `localStorage` se almacena como timestamp numérico (number)
   - En el componente `RecentTrackCard` se implementa una función `getTimestamp()` para normalizar los diferentes formatos

2. **Almacenamiento redundante del historial**:
   - En MongoDB a través de `RecentTrack` model
   - En `localStorage` como fallback
   - Sin mecanismo de sincronización entre ambos almacenes

3. **Diferencias en la representación de canciones**:
   - `Track` en `src/types/types.ts`
   - `Track` en `src/types/music.ts` (propiedades diferentes)
   - `IRecentTrack` en modelo de MongoDB
   - `EnrichedTrack` como extensión de `Track`
   - `PlayHistory` en `src/interfaces/playlist.interface.ts`

4. **Estrategias inconsistentes de retención de datos**:
   - En MongoDB: Límite de 50 canciones por usuario
   - En `localStorage`: También limitado a 50 canciones
   - Implementación duplicada de la lógica de limitación en múltiples lugares

5. **Visualización inconsistente de fechas**:
   - En `RecentTrackCard` se usa `formatRelativeTime()` para mostrar tiempo relativo
   - En `UserPage` se muestra `track.playedAt` directamente (sin formato)

## Inconsistencias específicas del Backend (Node.js)

1. **Mezcla de paradigmas de programación**:
   - En `node-server/server.js` se mezcla programación orientada a objetos con programación funcional
   - Algunos middlewares se implementan como funciones independientes, otros como parte del router
   - Uso inconsistente de promesas vs callbacks vs async/await

2. **Estructura monolítica del servidor Node.js**:
   - Todo el código principal está en un solo archivo `node-server/server.js` con más de 700 líneas
   - No hay separación clara entre rutas, controladores y servicios
   - La lógica de negocios está mezclada con la configuración del servidor

3. **Inconsistencias en el manejo de respuestas**:
   - Algunos endpoints usan `res.json({ success: true, data: ... })`
   - Otros usan `res.json(data)` directamente
   - Algunos incluyen metadata como `total`, `count`, otros no
   - Formato inconsistente de errores: a veces `res.status(400).json({ error: 'mensaje' })`, otras veces `res.json({ success: false, message: 'error' })`

4. **Manejo inconsistente de las solicitudes HTTP**:
   - Para Spotify, se usa `axios` con interceptadores
   - Para YouTube Music, se usa `fetch` directo
   - Mezcla de `GET` y `POST` para operaciones de lectura

5. **Problemas en gestión de dependencias**:
   - Dependencias no versionadas explícitamente en `package.json`
   - Algunas dependencias importadas pero no utilizadas
   - Otras utilizadas pero no declaradas explícitamente

## Inconsistencias específicas de la API Python

1. **Inconsistencias en el diseño API**:
   - La API Python no sigue un estándar REST consistente
   - Algunos endpoints usan parámetros en la URL, otros en el cuerpo de la solicitud
   - Formato de respuesta inconsistente entre diferentes endpoints

2. **Manejo de caché inconsistente**:
   - Sistema de caché basado en archivos con TTL global
   - Sin invalidación de caché cuando cambian los datos
   - Duplicación de lógica de caché entre diferentes funciones

3. **Inconsistencias en manejo de excepciones**:
   - Algunas funciones capturan excepciones específicas, otras usan try/except genérico
   - Diferentes formatos de respuesta para errores:
     - A veces devuelve un diccionario `{"error": mensaje}`
     - Otras veces lanza una excepción HTTP con `abort(400)`
     - En algunos casos retorna un objeto vacío o lista vacía

4. **Ausencia de validación de parámetros**:
   - No hay validación consistente de parámetros de entrada
   - Algunos endpoints verifican parámetros obligatorios, otros asumen valores predeterminados
   - Falta de tipado estático o anotaciones de tipo (type hints)

5. **Falta de documentación de API**:
   - No hay documentación mediante decoradores (Swagger/OpenAPI)
   - Comentarios insuficientes sobre parámetros esperados y respuestas
   - Sin pruebas automatizadas que documenten comportamiento esperado

## Deficiencias técnicas del servidor Python

1. **Problemas estructurales**:
   - El servidor usa Flask sin una estructura modular clara (blueprints)
   - Archivo principal `youtube_music_api.py` con más de 1000 líneas y múltiples responsabilidades
   - Configuración mezclada con lógica de negocios
   - Uso de variables globales en lugar de estructuras más organizadas
   - Falta de separación de responsabilidades (rutas, servicios, modelos)

2. **Problemas de rendimiento**:
   - Uso de la biblioteca `ytmusicapi` sin optimizaciones para consultas frecuentes
   - Cada solicitud a YouTube Music puede tardar varios segundos
   - Sin implementación de operaciones asíncronas (usa Flask sincrónico en lugar de ASGI)
   - Cacheo ineficiente: guarda respuestas completas en lugar de datos procesados
   - Sin implementación de streaming para respuestas grandes

3. **Deficiencias de seguridad**:
   - Sin validación rigurosa de entradas
   - No implementa limitación de tasa (rate limiting) para prevenir abusos
   - Vulnerabilidad potencial a ataques de deserialización por uso de `pickle` para caché
   - Sin implementación de autenticación entre servicios (Node.js puede acceder sin credenciales)
   - Uso directo de valores de entrada sin sanitización

4. **Problemas de gestión de recursos**:
   - Sin manejo adecuado de conexiones persistentes
   - Posibles fugas de memoria por objetos de caché que crecen indefinidamente
   - Sin implementación de cierre controlado (graceful shutdown)
   - Manejo de archivos sin garantía de liberación de recursos (faltan bloques `with`)
   - Sin controles para limitar consumo de memoria o CPU

5. **Deficiencias en el manejo de sesiones YouTube Music**:
   - La biblioteca `ytmusicapi` requiere recrear sesiones periódicamente
   - No hay mecanismo para refrescar automáticamente las credenciales
   - Faltan estrategias para manejar bloqueos temporales por parte de YouTube
   - No se implementa rotación de headers o proxies para evitar detección

6. **Problemas de mantenibilidad**:
   - Código con comentarios desactualizados o incorrectos
   - Múltiples versiones duplicadas del mismo archivo (backups)
   - Funciones excesivamente largas y complejas (algunas más de 100 líneas)
   - Convenciones de nombrado inconsistentes
   - Falta de pruebas unitarias o integración

7. **Deficiencias en logging y monitoreo**:
   - Configuración de logging inconsistente (mezcla de `print` y `logger`)
   - Sin niveles diferenciados de logging (debug vs error)
   - No se registran métricas de rendimiento o uso
   - Falta sistema para detectar y alertar sobre problemas
   - Sin información detallada en errores para facilitar depuración

8. **Problemas de despliegue**:
   - No está containerizado (falta Dockerfile)
   - Sin configuración para escalabilidad horizontal
   - Dependencias no especificadas con versiones exactas
   - Falta de scripts para inicialización y administración
   - Sin soporte para configuración vía variables de entorno

## Inconsistencias en la comunicación entre servicios

1. **Diferentes protocolos y formatos**:
   - Frontend a Node: API REST con JSON
   - Node a Python: API REST con JSON
   - Python a YouTube Music API: API específica con bibliotecas Python

2. **Transformación redundante de datos**:
   - Datos transformados múltiples veces en la cadena de servicios
   - Cada capa (Python, Node, Frontend) aplica su propia transformación
   - Pérdida potencial de información en las transformaciones sucesivas

3. **Manejo inconsistente de códigos de estado HTTP**:
   - Python API: Uso de códigos 4xx y 5xx para errores
   - Node.js: A veces devuelve código 200 con `{ success: false, error: ... }`
   - Frontend: No siempre verifica códigos de estado HTTP

4. **Manejo desincronizado de timeouts**:
   - Frontend: Timeout global para peticiones de 15000ms
   - Node.js: Timeout configurable para diferentes servicios
   - Python: Sin timeout explícito en muchos casos

5. **Autenticación inconsistente entre servicios**:
   - Frontend a Node.js: A veces usa cookies, otras veces no
   - Node.js a Python: Sin autenticación
   - Python a YouTube Music: Autenticación específica de YouTube Music

## Recomendaciones

1. **Centralizar la configuración de URLs**:
   - Usar exclusivamente una implementación de `getApiBaseUrl()`
   - Eliminar duplicaciones

2. **Estandarizar las variables de entorno**:
   - Unificar nombres de variables entre frontend, node-server y python-api
   - Eliminar variables obsoletas o documentar claramente la transición
   - Centralizar el acceso a variables de entorno en `src/env.mjs`
   - Estandarizar puertos para desarrollo local

3. **Estandarizar la construcción de URLs de API**:
   - Definir si `/api` forma parte de la URL base o se añade en cada llamada
   - Evitar URLs hardcodeadas
   - Crear constantes para todas las URLs base en un único archivo

4. **Unificar la detección de entorno**:
   - Crear una función auxiliar centralizada para detectar el entorno

5. **Estandarizar la gestión de errores y reintentos**:
   - Usar una única estrategia de reintentos para todos los servicios
   - Estandarizar el formato de las respuestas de error

6. **Estandarizar el manejo del modo demo**:
   - Centralizar la lógica del modo demo en un único servicio
   - Usar un enfoque consistente para detectar si está en modo demo

7. **Estandarizar sistemas de cache**:
   - Implementar una estrategia de cache consistente en toda la aplicación
   - Usar tiempos de expiración coherentes

8. **Unificar el sistema de tipos**:
   - Centralizar tipos en `src/types/types.ts`
   - Evitar redefiniciones y extensiones dispersas en el código
   - Considerar añadir tipado a Python con type hints y a JavaScript con JSDoc o migrar a TypeScript

9. **Mejorar la seguridad**:
   - Eliminar credenciales hardcodeadas de los archivos .env
   - Usar variables de entorno secretas en entornos de producción

10. **Estandarizar la configuración de CORS**:
    - Utilizar un enfoque coherente en todos los servicios
    - Evitar configuraciones comentadas que puedan causar confusión

11. **Unificar el sistema de historial y reproducción**:
    - Estandarizar el tipo de `playedAt` a un único formato (preferiblemente timestamp numérico)
    - Implementar un sistema de sincronización entre localStorage y MongoDB
    - Centralizar la lógica de limitación del historial

12. **Mejorar la arquitectura de la API de YouTube**:
    - Centralizar el acceso a la API de YouTube Music
    - Estandarizar el manejo de errores y reintentos
    - Unificar los tipos de datos y respuestas

13. **Refactorizar el servidor Node.js**:
    - Dividir el archivo `server.js` en módulos más pequeños
    - Separar rutas, controladores y servicios
    - Implementar un formato estándar para respuestas y errores
    - Migrar a TypeScript para mejor tipado y detección de errores

14. **Mejorar la API Python**:
    - Implementar una arquitectura más modular
    - Añadir validación de parámetros de entrada
    - Usar type hints para mejorar la documentación y detectar errores
    - Implementar un manejo de excepciones más consistente
    - Documentar la API con Swagger/OpenAPI

15. **Estandarizar la comunicación entre servicios**:
    - Definir un formato estándar para las solicitudes y respuestas entre servicios
    - Centralizar la transformación de datos en cada capa
    - Unificar los mecanismos de timeout y reintentos
    - Implementar un manejo consistente de errores entre servicios

16. **Simplificar la arquitectura general**:
    - Evaluar si es necesario tener tres capas (Frontend, Node.js, Python)
    - Considerar la posibilidad de integrar la funcionalidad de Python en Node.js
    - Alternativamente, considerar trasladar más lógica al servidor Python y simplificar el Node.js a un proxy puro

17. **Modernizar el servidor Python**:
    - Migrar de Flask a FastAPI para mejor rendimiento y documentación automática
    - Reestructurar el código con una arquitectura modular (routers, servicios, modelos)
    - Implementar operaciones asíncronas para mejorar rendimiento
    - Añadir validación de datos con Pydantic
    - Dockerizar la aplicación para facilitar despliegue

18. **Mejorar el rendimiento del servidor Python**:
    - Implementar un mejor sistema de caché (Redis en lugar de archivos)
    - Optimizar consultas a YouTube Music mediante pooling de conexiones
    - Añadir streaming de respuestas para grandes volúmenes de datos
    - Implementar procesamiento en paralelo para consultas independientes
    - Establecer un sistema de monitoreo para detectar cuellos de botella

19. **Reforzar la seguridad del servidor Python**:
    - Implementar autenticación basada en tokens entre Node.js y Python
    - Añadir validación estricta de entradas con esquemas
    - Implementar rate limiting para prevenir abusos
    - Reemplazar el sistema de caché basado en pickle por uno más seguro
    - Añadir encabezados de seguridad HTTP

20. **Mejorar la mantenibilidad del servidor Python**:
    - Dividir el código en módulos con responsabilidades claras
    - Implementar pruebas unitarias y de integración
    - Estandarizar convenciones de código (usar black, isort, flake8)
    - Añadir documentación detallada
    - Implementar CI/CD para verificación automática

## Archivos revisados
- ✅ `src/services/youtube/youtube-music-api.ts`
- ✅ `src/services/spotify.ts`
- ✅ `src/services/utils/api-config.ts`
- ✅ `src/services/recommendations/sources/spotify.ts`
- ✅ `src/services/demo/demo-data-service.ts` (parcial)
- ✅ `src/lib/api-config.ts`
- ✅ `src/lib/spotify.ts`
- ✅ `src/lib/server-utils.ts`
- ✅ `src/lib/auth.ts`
- ✅ `src/config/api-config.ts`
- ✅ `src/env.mjs`
- ✅ `src/app/api/auth/login/route.ts`
- ✅ `src/app/api/auth/[...nextauth]/route.ts`
- ✅ `src/app/api/spotify/route.ts` (parcial)
- ✅ `src/app/api/youtube/route.ts`
- ✅ `src/components/ServerStatus.tsx`
- ✅ `src/components/PlayerBar.tsx` (parcial)
- ✅ `src/contexts/PlayerContext.tsx` (parcial)
- ✅ `src/types/types.ts`
- ✅ `src/types/music.ts`
- ✅ `src/models/RecentTrack.ts`
- ✅ `src/services/history/recentTracksService.ts`
- ✅ `src/lib/db/mongodb.ts`
- ✅ `src/app/api/history/status/route.ts`
- ✅ `src/app/(routes)/home/page.tsx` (parcial, componente RecentTrackCard)
- ✅ `node-server/server.js` (parcial)
- ✅ `node-server/.env`
- ✅ `node-server/.env.example`
- ✅ `node-server/demo-handler.js` (parcial)
- ✅ `python-api/app.py`
- ✅ `python-api/.env`
- ✅ `python-api/.env.example`
- ✅ `python-api/youtube_music_api.py` (parcial)
- ✅ `.env`
- ✅ `.env.example`
- ✅ `vercel.json`
- ✅ `next.config.js`
- ✅ `docs/es/TECHNICAL.md` (parcial)
- ✅ `docs/en/TECHNICAL.md` (parcial)

## Archivos pendientes por analizar

### Frontend (src)
1. **Componentes y Páginas**:
   - `src/app/layout.tsx` - Componente principal de layout
   - `src/app/page.tsx` - Página principal
   - `src/app/(routes)/home/page.tsx` - Página de inicio
   - `src/app/(routes)/search/page.tsx` - Página de búsqueda
   - `src/components/Navbar.tsx` - Barra de navegación
   - `src/components/UnifiedMusicCard.tsx` - Componente de tarjeta de música

2. **Servicios y APIs**:
   - `src/services/lyricsService.ts` - Servicio para letras de canciones
   - `src/services/imageResolver.ts` - Servicio para resolución de imágenes
   - `src/services/youtube/index.ts` - Servicios de YouTube
   - `src/services/search/index.ts` - Servicios de búsqueda
   - `src/services/player/index.ts` - Servicios de reproductor

3. **Utilidades y Configuración**:
   - `src/lib/api-throttle.ts` - Implementación de throttling para APIs
   - `src/lib/request-throttler.ts` - Throttler genérico de peticiones
   - `src/lib/cache.ts` - Sistema de caché
   - `src/lib/utils.ts` - Utilidades generales
   - `src/lib/mongodb.ts` - Configuración de MongoDB

4. **Modelos y Hooks**:
   - `src/hooks/useSpotify.ts` - Hook para integración con Spotify
   - `src/hooks/useLocalStorage.ts` - Hook para almacenamiento local
   - `src/lib/db/models/User.ts` - Modelo de usuario

### Backend Node.js
1. `node-server/scripts/` - Scripts de utilidad para el servidor Node
2. `node-server/demo-data/` - Datos de demostración
3. `node-server/package.json` - Dependencias y scripts del servidor Node

### Backend Python
1. `python-api/requirements.txt` - Dependencias del servicio Python
2. `python-api/test_music.py` - Tests para API de música
3. `python-api/cache/` - Implementación de caché en Python

### Configuración y Documentación
1. `package.json` - Dependencias y scripts del proyecto principal
2. `tailwind.config.js` - Configuración de TailwindCSS
3. `docs/es/README.md` y `docs/en/README.md` - Documentación principal
